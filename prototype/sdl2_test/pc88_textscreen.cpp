// PC-8801 Text Screen Emulator Implementation

#include "pc88_textscreen.h"
#include <stdio.h>

// Helper function to get font bitmap for a character
static const uint8_t* GetFont8x8(uint8_t ch) {
    static const uint8_t empty[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

    // Font bitmaps stored in a lookup table
    static const uint8_t font_bitmaps[][8] = {
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // space
        {0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00}, // !
        {0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00}, // "
        {0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00}, // (
        {0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00}, // )
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30}, // ,
        {0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00}, // -
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00}, // .
        {0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x00}, // /
        {0x3C, 0x66, 0x6E, 0x76, 0x66, 0x66, 0x3C, 0x00}, // 0
        {0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00}, // 1
        {0x3C, 0x66, 0x06, 0x0C, 0x18, 0x30, 0x7E, 0x00}, // 2
        {0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00}, // 3
        {0x0C, 0x1C, 0x2C, 0x4C, 0x7E, 0x0C, 0x0C, 0x00}, // 4
        {0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00}, // 5
        {0x1C, 0x30, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00}, // 6
        {0x7E, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00}, // 7
        {0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00}, // 8
        {0x3C, 0x66, 0x66, 0x3E, 0x06, 0x0C, 0x38, 0x00}, // 9
        {0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00}, // :
        {0x3C, 0x66, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x00}, // ?
        {0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00}, // A
        {0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00}, // B
        {0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00}, // C
        {0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00}, // D
        {0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x7E, 0x00}, // E
        {0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x00}, // F
        {0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00}, // G
        {0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00}, // H
        {0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00}, // I
        {0x3E, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38, 0x00}, // J
        {0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00}, // K
        {0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00}, // L
        {0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x00}, // M
        {0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00}, // N
        {0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00}, // O
        {0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00}, // P
        {0x3C, 0x66, 0x66, 0x66, 0x6A, 0x6C, 0x36, 0x00}, // Q
        {0x7C, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0x66, 0x00}, // R
        {0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00}, // S
        {0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00}, // T
        {0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00}, // U
        {0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00}, // V
        {0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00}, // W
        {0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00}, // X
        {0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00}, // Y
        {0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00}, // Z
        {0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x3E, 0x00}, // a
        {0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x00}, // b
        {0x00, 0x00, 0x3C, 0x66, 0x60, 0x66, 0x3C, 0x00}, // c
        {0x06, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00}, // d
        {0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00}, // e
        {0x1C, 0x30, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x00}, // f
        {0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x3C}, // g
        {0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00}, // h
        {0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00}, // i
        {0x06, 0x00, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C}, // j
        {0x60, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0x00}, // k
        {0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00}, // l
        {0x00, 0x00, 0x66, 0x7F, 0x6B, 0x6B, 0x63, 0x00}, // m
        {0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00}, // n
        {0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00}, // o
        {0x00, 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60}, // p
        {0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x06}, // q
        {0x00, 0x00, 0x6C, 0x76, 0x60, 0x60, 0x60, 0x00}, // r
        {0x00, 0x00, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x00}, // s
        {0x30, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x1C, 0x00}, // t
        {0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00}, // u
        {0x00, 0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00}, // v
        {0x00, 0x00, 0x63, 0x6B, 0x6B, 0x7F, 0x36, 0x00}, // w
        {0x00, 0x00, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x00}, // x
        {0x00, 0x00, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x3C}, // y
        {0x00, 0x00, 0x7E, 0x0C, 0x18, 0x30, 0x7E, 0x00}, // z
    };

    // Character to index mapping
    static const struct { uint8_t ch; uint8_t idx; } char_map[] = {
        {' ', 0}, {'!', 1}, {'"', 2}, {'(', 3}, {')', 4}, {',', 5}, {'-', 6}, {'.', 7}, {'/', 8},
        {'0', 9}, {'1', 10}, {'2', 11}, {'3', 12}, {'4', 13}, {'5', 14}, {'6', 15}, {'7', 16}, {'8', 17}, {'9', 18},
        {':', 19}, {'?', 20},
        {'A', 21}, {'B', 22}, {'C', 23}, {'D', 24}, {'E', 25}, {'F', 26}, {'G', 27}, {'H', 28}, {'I', 29}, {'J', 30},
        {'K', 31}, {'L', 32}, {'M', 33}, {'N', 34}, {'O', 35}, {'P', 36}, {'Q', 37}, {'R', 38}, {'S', 39}, {'T', 40},
        {'U', 41}, {'V', 42}, {'W', 43}, {'X', 44}, {'Y', 45}, {'Z', 46},
        {'a', 47}, {'b', 48}, {'c', 49}, {'d', 50}, {'e', 51}, {'f', 52}, {'g', 53}, {'h', 54}, {'i', 55}, {'j', 56},
        {'k', 57}, {'l', 58}, {'m', 59}, {'n', 60}, {'o', 61}, {'p', 62}, {'q', 63}, {'r', 64}, {'s', 65}, {'t', 66},
        {'u', 67}, {'v', 68}, {'w', 69}, {'x', 70}, {'y', 71}, {'z', 72},
    };

    // Look up character
    for (size_t i = 0; i < sizeof(char_map) / sizeof(char_map[0]); i++) {
        if (char_map[i].ch == ch) {
            return font_bitmaps[char_map[i].idx];
        }
    }

    return empty;  // Return blank for undefined characters
}

PC88TextScreen::PC88TextScreen()
    : cursor_x(0)
    , cursor_y(0)
{
    Clear();
}

PC88TextScreen::~PC88TextScreen()
{
}

void PC88TextScreen::Clear()
{
    memset(text_vram, ' ', sizeof(text_vram));
    memset(attr_vram, 7, sizeof(attr_vram));  // 白
}

void PC88TextScreen::PutChar(int x, int y, char ch, uint8_t color)
{
    if (x >= 0 && x < TEXT_COLS && y >= 0 && y < TEXT_ROWS) {
        text_vram[y][x] = ch;
        attr_vram[y][x] = color;
    }
}

void PC88TextScreen::PutString(int x, int y, const char* str, uint8_t color)
{
    int cx = x;
    while (*str && cx < TEXT_COLS) {
        if (*str == '\n') {
            cx = x;
            y++;
            if (y >= TEXT_ROWS) break;
        } else {
            PutChar(cx++, y, *str, color);
        }
        str++;
    }
}

void PC88TextScreen::Print(const char* str, uint8_t color)
{
    while (*str) {
        if (*str == '\n') {
            cursor_x = 0;
            cursor_y++;
            if (cursor_y >= TEXT_ROWS) {
                Scroll();
                cursor_y = TEXT_ROWS - 1;
            }
        } else {
            PutChar(cursor_x, cursor_y, *str, color);
            cursor_x++;
            if (cursor_x >= TEXT_COLS) {
                cursor_x = 0;
                cursor_y++;
                if (cursor_y >= TEXT_ROWS) {
                    Scroll();
                    cursor_y = TEXT_ROWS - 1;
                }
            }
        }
        str++;
    }
}

void PC88TextScreen::Scroll()
{
    // 1行スクロール
    memmove(&text_vram[0][0], &text_vram[1][0], sizeof(text_vram[0]) * (TEXT_ROWS - 1));
    memmove(&attr_vram[0][0], &attr_vram[1][0], sizeof(attr_vram[0]) * (TEXT_ROWS - 1));

    // 最終行をクリア
    memset(&text_vram[TEXT_ROWS - 1][0], ' ', TEXT_COLS);
    memset(&attr_vram[TEXT_ROWS - 1][0], 7, TEXT_COLS);
}

const uint8_t* PC88TextScreen::GetFont(uint8_t ch)
{
    return GetFont8x8(ch);
}

void PC88TextScreen::Render(uint8_t* framebuffer, int width, int height, int pitch)
{
    // フレームバッファをクリア（黒）
    for (int y = 0; y < height; y++) {
        memset(&framebuffer[y * pitch], 0, width);
    }

    // テキストを描画
    for (int ty = 0; ty < TEXT_ROWS; ty++) {
        for (int tx = 0; tx < TEXT_COLS; tx++) {
            uint8_t ch = text_vram[ty][tx];
            uint8_t color = attr_vram[ty][tx];
            const uint8_t* font = GetFont(ch);

            int px = tx * FONT_WIDTH;
            int py = ty * FONT_HEIGHT;

            // 8x8フォントを描画
            for (int fy = 0; fy < FONT_HEIGHT; fy++) {
                uint8_t line = font[fy];
                for (int fx = 0; fx < FONT_WIDTH; fx++) {
                    if (line & (0x80 >> fx)) {
                        int x = px + fx;
                        int y = py + fy;
                        if (x < width && y < height) {
                            framebuffer[y * pitch + x] = color;
                        }
                    }
                }
            }
        }
    }
}
